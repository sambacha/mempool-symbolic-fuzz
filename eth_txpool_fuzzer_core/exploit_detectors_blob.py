# eth_txpool_fuzzer_core/exploit_detectors_blob.py
"""
Defines exploit conditions specifically for EIP-4844 blob transactions.
"""

from typing import Dict, Any

from eth_txpool_fuzzer_core.exploit_detectors import ExploitCondition
from eth_txpool_fuzzer_core.state import get_symbolic_pool_state, get_total_pending_tx_count

class BlobPoolStallExploit(ExploitCondition):
    """
    Detects an exploit if the transaction pool contains blob transactions
    but the total pending transaction count (including non-blobs) drops to zero,
    suggesting a stall or unexpected clearing related to blob processing.
    """
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_state = get_symbolic_pool_state(txpool_content)
        pending_tx_count = get_total_pending_tx_count(txpool_content)

        has_blob_txs = 'B' in symbolic_state or 'I' in symbolic_state

        if has_blob_txs and pending_tx_count == 0:
            print("INFO: BlobPoolStallExploit triggered: Pool contained blobs but pending count is zero.")
            return True
        return False

class BlobGasPriceManipulationExploit(ExploitCondition):
    """
    Detects an exploit if the transaction pool contains blob transactions
    with very low `maxFeePerBlobGas` that are still accepted, or if
    a high `maxFeePerBlobGas` transaction is unexpectedly dropped.
    This is a heuristic and might need tuning.
    """
    def __init__(self,
                 low_price_threshold: int = 1, # Below this is considered very low
                 high_price_threshold: int = 1000 # Above this is considered very high
                ):
        self.low_price_threshold = low_price_threshold
        self.high_price_threshold = high_price_threshold

    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        pending_txs = txpool_content.get('pending', {})

        for sender_addr, txs_by_nonce_str in pending_txs.items():
            for nonce_str in txs_by_nonce_str:
                tx_details = txs_by_nonce_str[nonce_str]
                try:
                    tx_type = int(tx_details.get('type', '0'), 16) if 'type' in tx_details else 0
                    if tx_type == 3: # It's a blob transaction
                        max_fee_per_blob_gas = int(tx_details.get('maxFeePerBlobGas', '0'), 16) if 'maxFeePerBlobGas' in tx_details else 0

                        # Example: If a blob tx with very low gas price is accepted
                        if max_fee_per_blob_gas <= self.low_price_threshold:
                            print(f"INFO: BlobGasPriceManipulationExploit triggered: Low blob gas price ({max_fee_per_blob_gas}) accepted.")
                            return True

                        # Example: If a blob tx with very high gas price is unexpectedly missing (requires external check)
                        # This specific check is harder to do purely from txpool_content without knowing what was sent.
                        # For now, focus on accepted low-price blobs.

                except ValueError:
                    print(f"WARN: Malformed tx details for blob gas price check on {sender_addr} N:{nonce_str}.")
                    continue
        return False

class InvalidBlobTxAcceptanceExploit(ExploitCondition):
    """
    Detects an exploit if the symbolic pool state contains 'I' (invalid blob) transactions,
    indicating that the client accepted a malformed blob transaction into its pool.
    """
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_state = get_symbolic_pool_state(txpool_content)
        if 'I' in symbolic_state:
            print("INFO: InvalidBlobTxAcceptanceExploit triggered: Symbolic state contains 'I' (invalid blob).")
            return True
        return False
