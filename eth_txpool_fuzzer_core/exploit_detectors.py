# eth_txpool_fuzzer_core/exploit_detectors.py
"""
Defines conditions for identifying "exploits" or interesting states found by the fuzzer.
"""

import abc # Abstract Base Classes
from typing import Dict, Any, List, Optional

from . import state as core_state_analysis # Renamed import to avoid conflict
from . import config as core_config

# TODO: Set up a proper logger for this module
# import logging
# logger = logging.getLogger(__name__)

class ExploitCondition(abc.ABC):
    """
    Abstract base class for defining conditions that constitute an exploit
    or a noteworthy state during fuzzing.
    """

    @abc.abstractmethod
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        """
        Evaluates if the given transaction pool content meets the exploit condition.

        :param txpool_content: The raw content of the transaction pool
                               (e.g., from EthereumClient.get_txpool_content()).
        :return: True if the condition is met (exploit detected), False otherwise.
        """
        pass

class CompositeExploitCondition(ExploitCondition):
    """
    A composite exploit condition that combines multiple individual exploit conditions.
    If any of the contained conditions are met, this composite condition is met.
    """
    def __init__(self, conditions: List[ExploitCondition]):
        self.conditions = conditions

    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        """
        Checks if any of the contained exploit conditions are met.
        """
        for condition in self.conditions:
            if condition.check_condition(txpool_content):
                return True
        return False

class PendingEmptyExploit(ExploitCondition):
    """
    Detects an exploit if the 'pending' queue in the txpool becomes empty
    under certain fuzzing scenarios.
    Based on logic from mpfuzz_e2a.py and mpfuzz_e2b.py's is_exploit.
    """
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        pending_tx_count = core_state_analysis.get_total_pending_tx_count(txpool_content)
        if pending_tx_count == 0:
            # TODO: Log: print("INFO: PendingEmptyExploit triggered.")
            return True
        return False

class LowCostStateExploit(ExploitCondition):
    """
    Detects an exploit if a state with no 'Normal' transactions has a low calculated "cost".
    This is based on the logic from mpfuzz.py's is_exploit function.
    Cost formula: parent_count * 4 + child_count * 100
    Threshold: <= txpool_size
    """
    def __init__(self,
                 txpool_size_override: Optional[int] = None,
                 # Symbolic state parsing parameters (should match fuzzer's main config)
                 normal_price_indicator: int = core_config.STATE_NORMAL_TX_PRICE_INDICATOR,
                 parent_replace_threshold: int = core_config.STATE_PARENT_REPLACEMENT_PRICE_THRESHOLD,
                 child_val_threshold: int = core_config.STATE_CHILD_VALUE_THRESHOLD
                ):
        self.txpool_size = txpool_size_override if txpool_size_override is not None else core_config.DEFAULT_TXPOOL_SIZE
        self.normal_price_indicator = normal_price_indicator
        self.parent_replace_threshold = parent_replace_threshold
        self.child_val_threshold = child_val_threshold

        # Original threshold was `3*txpool_size/3`, which is `txpool_size`.
        self.cost_limit_factor = 1.0
        # TODO: Log: print(f"INFO: LowCostStateExploit initialized. TxPoolSize: {self.txpool_size}, CostLimitFactor: {self.cost_limit_factor}")


    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_str = core_state_analysis.get_symbolic_pool_state(
            txpool_content,
            txpool_size_config=self.txpool_size,
            normal_tx_price_indicator=self.normal_price_indicator,
            parent_replacement_price_threshold=self.parent_replace_threshold,
            child_value_threshold=self.child_val_threshold
        )

        normal_tx_count = symbolic_str.count('N')

        # As per reflection, for mpfuzz.py's logic, 'R' (Replacement) was effectively
        # counted as 'P' for the purpose of `parentNumber`.
        parent_tx_count = symbolic_str.count('P') + symbolic_str.count('R')
        child_c_tx_count = symbolic_str.count('C') # Only 'C' type children contribute to this cost

        # Cost calculation from mpfuzz.py
        calculated_state_cost = (parent_tx_count * 4) + (child_c_tx_count * 100)

        cost_threshold = self.cost_limit_factor * self.txpool_size

        if normal_tx_count == 0 and calculated_state_cost <= cost_threshold:
            # TODO: Log: print(f"INFO: LowCostStateExploit triggered. Cost: {calculated_state_cost}, Threshold: {cost_threshold}")
            return True
        return False

class EpsilonCostExploit(ExploitCondition):
    """
    Detects an exploit based on a cost calculation involving an epsilon factor,
    and explicitly considers 'R' (replacement) transactions.
    Based on logic from mpfuzz_epsilon.py's is_exploit.
    Cost: P*4 + R*5 + C*100
    Threshold: <= epsilon * (3 * txpool_size)
    """
    def __init__(self,
                 epsilon_value: float, # Epsilon factor, typically (0, 1]
                 txpool_size_override: Optional[int] = None,
                 # Symbolic state parsing parameters
                 normal_price_indicator: int = core_config.STATE_NORMAL_TX_PRICE_INDICATOR,
                 parent_replace_threshold: int = core_config.STATE_PARENT_REPLACEMENT_PRICE_THRESHOLD,
                 child_val_threshold: int = core_config.STATE_CHILD_VALUE_THRESHOLD
                ):
        if not (0.0 < epsilon_value): # Epsilon should be positive
            # TODO: Log error or raise ValueError
            print(f"ERROR: Epsilon value for EpsilonCostExploit must be positive. Got: {epsilon_value}")
            # Defaulting to a small positive to prevent division by zero or negative thresholds.
            # A scenario should ensure this is configured correctly.
            self.epsilon = 0.1
        else:
            self.epsilon = epsilon_value

        self.txpool_size = txpool_size_override if txpool_size_override is not None else core_config.DEFAULT_TXPOOL_SIZE
        self.normal_price_indicator = normal_price_indicator
        self.parent_replace_threshold = parent_replace_threshold
        self.child_val_threshold = child_val_threshold

        # Original threshold scaling factor from mpfuzz_epsilon.py was 3.0
        self.threshold_base_scaling_factor = 3.0
        # TODO: Log: print(f"INFO: EpsilonCostExploit initialized. Epsilon: {self.epsilon}, TxPoolSize: {self.txpool_size}")


    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_str = core_state_analysis.get_symbolic_pool_state(
            txpool_content,
            txpool_size_config=self.txpool_size,
            normal_tx_price_indicator=self.normal_price_indicator,
            parent_replacement_price_threshold=self.parent_replace_threshold,
            child_value_threshold=self.child_val_threshold
        )

        normal_tx_count = symbolic_str.count('N')
        parent_p_tx_count = symbolic_str.count('P') # 'P' type parents
        parent_r_tx_count = symbolic_str.count('R') # 'R' type (replacement) parents
        child_c_tx_count = symbolic_str.count('C')  # Only 'C' type children

        # Cost calculation from mpfuzz_epsilon.py
        calculated_state_cost = (parent_p_tx_count * 4) + \
                                (parent_r_tx_count * 5) + \
                                (child_c_tx_count * 100)

        cost_threshold = self.epsilon * (self.threshold_base_scaling_factor * self.txpool_size)

        if normal_tx_count == 0 and calculated_state_cost <= cost_threshold:
            # TODO: Log: print(f"INFO: EpsilonCostExploit triggered. Cost: {calculated_state_cost}, Threshold: {cost_threshold}")
            return True
        return False
