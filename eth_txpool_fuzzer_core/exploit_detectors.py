"""
Defines conditions for identifying "exploits" or interesting states found by the fuzzer.
"""

import abc
from typing import Dict, Any, List, Optional

from . import state as core_state_analysis
from . import config as core_config


class ExploitCondition(abc.ABC):
    """
    Abstract base class for defining conditions that constitute an exploit
    or a noteworthy state during fuzzing.
    """

    @abc.abstractmethod
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        """
        Evaluates if the given transaction pool content meets the exploit condition.

        :param txpool_content: The raw content of the transaction pool
                               (e.g., from EthereumClient.get_txpool_content()).
        :return: True if the condition is met (exploit detected), False otherwise.
        """
        pass

class CompositeExploitCondition(ExploitCondition):
    """
    A composite exploit condition that combines multiple individual exploit conditions.
    If any of the contained conditions are met, this composite condition is met.
    """
    def __init__(self, conditions: List[ExploitCondition]):
        self.conditions = conditions

    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        """
        Checks if any of the contained exploit conditions are met.
        """
        for condition in self.conditions:
            if condition.check_condition(txpool_content):
                return True
        return False

class PendingEmptyExploit(ExploitCondition):
    """
    Detects an exploit if the 'pending' queue in the txpool becomes empty
    under certain fuzzing scenarios.
    Based on logic from mpfuzz_e2a.py and mpfuzz_e2b.py's is_exploit.
    """
    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        pending_tx_count = core_state_analysis.get_total_pending_tx_count(txpool_content)
        if pending_tx_count == 0:
            return True
        return False

class LowCostStateExploit(ExploitCondition):
    """
    Detects an exploit if a state with no 'Normal' transactions has a low calculated "cost".
    This is based on the logic from mpfuzz.py's is_exploit function.
    Cost formula: parent_count * 4 + child_count * 100
    Threshold: <= txpool_size
    """
    def __init__(self,
                 txpool_size_override: Optional[int] = None,
                 normal_price_indicator: int = core_config.STATE_NORMAL_TX_PRICE_INDICATOR,
                 parent_replace_threshold: int = core_config.STATE_PARENT_REPLACEMENT_PRICE_THRESHOLD,
                 child_val_threshold: int = core_config.STATE_CHILD_VALUE_THRESHOLD
                ):
        self.txpool_size = txpool_size_override if txpool_size_override is not None else core_config.DEFAULT_TXPOOL_SIZE
        self.normal_price_indicator = normal_price_indicator
        self.parent_replace_threshold = parent_replace_threshold
        self.child_val_threshold = child_val_threshold

        self.cost_limit_factor = 1.0


    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_str = core_state_analysis.get_symbolic_pool_state(
            txpool_content,
            txpool_size_config=self.txpool_size,
            normal_tx_price_indicator=self.normal_price_indicator,
            parent_replacement_price_threshold=self.parent_replace_threshold,
            child_value_threshold=self.child_val_threshold
        )

        normal_tx_count = symbolic_str.count('N')

        parent_tx_count = symbolic_str.count('P') + symbolic_str.count('R')
        child_c_tx_count = symbolic_str.count('C')

        calculated_state_cost = (parent_tx_count * 4) + (child_c_tx_count * 100)

        cost_threshold = self.cost_limit_factor * self.txpool_size

        if normal_tx_count == 0 and calculated_state_cost <= cost_threshold:
            return True
        return False

class EpsilonCostExploit(ExploitCondition):
    """
    Detects an exploit based on a cost calculation involving an epsilon factor,
    and explicitly considers 'R' (replacement) transactions.
    Based on logic from mpfuzz_epsilon.py's is_exploit.
    Cost: P*4 + R*5 + C*100
    Threshold: <= epsilon * (3 * txpool_size)
    """
    def __init__(self,
                 epsilon_value: float,
                 txpool_size_override: Optional[int] = None,
                 normal_price_indicator: int = core_config.STATE_NORMAL_TX_PRICE_INDICATOR,
                 parent_replace_threshold: int = core_config.STATE_PARENT_REPLACEMENT_PRICE_THRESHOLD,
                 child_val_threshold: int = core_config.STATE_CHILD_VALUE_THRESHOLD
                ):
        if not (0.0 < epsilon_value):
            print(f"ERROR: Epsilon value for EpsilonCostExploit must be positive. Got: {epsilon_value}")
            self.epsilon = 0.1
        else:
            self.epsilon = epsilon_value

        self.txpool_size = txpool_size_override if txpool_size_override is not None else core_config.DEFAULT_TXPOOL_SIZE
        self.normal_price_indicator = normal_price_indicator
        self.parent_replace_threshold = parent_replace_threshold
        self.child_val_threshold = child_val_threshold

        self.threshold_base_scaling_factor = 3.0


    def check_condition(self, txpool_content: Dict[str, Any]) -> bool:
        symbolic_str = core_state_analysis.get_symbolic_pool_state(
            txpool_content,
            txpool_size_config=self.txpool_size,
            normal_tx_price_indicator=self.normal_price_indicator,
            parent_replacement_price_threshold=self.parent_replace_threshold,
            child_value_threshold=self.child_val_threshold
        )

        normal_tx_count = symbolic_str.count('N')
        parent_p_tx_count = symbolic_str.count('P')
        parent_r_tx_count = symbolic_str.count('R')
        child_c_tx_count = symbolic_str.count('C')

        calculated_state_cost = (parent_p_tx_count * 4) + \
                                (parent_r_tx_count * 5) + \
                                (child_c_tx_count * 100)

        cost_threshold = self.epsilon * (self.threshold_base_scaling_factor * self.txpool_size)

        if normal_tx_count == 0 and calculated_state_cost <= cost_threshold:
            return True
        return False
